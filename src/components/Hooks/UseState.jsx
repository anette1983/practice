import { useState } from "react";

const UseState = () => {
  const [value, setValue] = useState(0);

  return (
    <div>
      {value}
      <br />
      <button type="button" onClick={() => setValue(value + 1)}>
        Increment value by 1
      </button>
    </div>
  );
};

export default UseState;

/*Виклик хука useState створює стан і метод, який змінюватиме його значення. У якості параметра хук приймає початковий стан, в нашому випадку число 0. У стані може зберігатися будь-який тип даних.

Хук useState повертає масив із двох елементів: перший - поточне значення стану, другий - функцію для його зміни, яку можна використовувати де завгодно, наприклад, в обробнику подій. React буде зберігати цей стан між рендерами. Використовуючи деструктуризацію, можна задати будь-які імена змінних.*/
/*Функція оновлення стану схожа з this.setState у класах, але не зшиває новий і старий стан разом у разі якщо у стані зберігається об'єкт. У решті все як зі звичайним станом компонента. Основна відмінність: у класовому компоненті ми можемо створити лише один загальний стан, а у функціональному - скільки завгодно, і вони будуть незалежні один від одного. */

/*// ❌ Погано
const App = () => {
    const [state, setState] = useState({
      username: "",
      todos: [{ text: "Learn hooks" }],
      isModalOpen: false,
    });
  };
  
  // ✅ Добре
  const App = () => {
    const [username, setUsername] = useState("");
    const [todos, setTodos] = useState([{ text: "Learn hooks" }]);
    const [isModalOpen, setIsModalOpen] = useState(false);
  }; */

//   Будь-які хуки можна викликати лише на верхньому рівні компонента функції. Тобто, поза циклами, умовами, вкладеними функціями і т.п. 

