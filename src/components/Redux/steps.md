Програма планувальник завдань, в якій можна створити, видалити, відзначити
завдання як виконане і відфільтрувати задачі за статусом.

базові вимоги: Інтерфейс повинен складатися з кількох частин: Шапка з
інформацією про завдання та фільтри Форма з полем введення для створення нових
завдань Список завдань У шапці необхідно відображати: Кількість виконаних та
невиконаних завдань Фільтри списку завдань зі значеннями «All», «Active» та
«Completed» У кожного елементу списку завдань має бути: Абзац з текстом який
вводив у форму користувач під час створення завдання Чекбокс перемикання статусу
«виконано» Кнопка видалення завдання

1. Проектування стану дві основні частини: список завдань, з яких можна отримати
   всі необхідні дані про кількість та статус завдань, та значення фільтрів
   списку завдань.

```r
const appState = {
  tasks: [],
  filters: {
    status: "all",
  },
};
```

властивість tasks для масиву всіх завдань та filters для можливих фільтрів

завдання: { id: 0, text: "Learn HTML and CSS", completed: true },

2. Проектування екшенів

Складемо список подій, які можуть бути в нашому додатку:

Додати нове завдання з текстом, введеним користувачем Видалити завдання
Переключити статус завдання Змінити значення фільтра статусу

3. встановлення npm install redux npm install react-redux Redux Toolkit -
   надбудову над базовими концепціями та конструкціями Redux

Стор (store) (файл store.js) Об'єкт, який містить повний стан програми, методи
доступу до стану та відправлення екшенів. Створення: фкція createStore(reducer,
preloadedState, enhancer)

reducer - функція із логікою зміни стану Redux. Обов'язковий параметр.
preloadedState - початковий стан програми. Це має бути об'єкт тієї ж форми, що
й, як мінімум, частина стану. Необов'язковий параметр. enhancer - функція
розширення можливостей стору. Необов'язковий параметр.

Після створення стору необхідно зв'язати його з компонентами React, щоб вони
могли отримувати доступ до стору та його методів. огортаємо в індекс джс у
компонент провайдер <Provider store={store}> <App /> </Provider>

4. додаємо розширення для браузера npm install @redux-devtools/extension
   використовуємо у файлі стор джс // Створюємо розширення стора, щоб додати
   інструменти розробника const enhancer = devToolsEnhancer(); export const
   store = createStore(rootReducer, enhancer);

Підписка на стор хук useSelector(selector). Аргументом він приймає функцію, яка
оголошує один параметр state - весь об'єкт стану Redux, який буде автоматично
переданий функції хуком useSelector import { useSelector } from "react-redux";
const MyComponent = () => { // Отримуємо необхідну частину стану const value =
useSelector(state => state.some.value); };

Фільтр за статусом Збережемо можливі значення фільтра як об'єкта, щоб повторно
використовувати їх у різних місцях програми: компоненті StatusFilter для
обчислення поточного активного фільтра та відправки екшенів зміни фільтра,
компоненті TaskList для обчислення списку видимих завдань, а також
функції-редюсері в якій потім будемо обробляти екшен зміни фільтра.

```js
src / redux / constants.js;
export const statusFilters = Object.freeze({
  all: 'all',
  active: 'active',
  completed: 'completed',
});
```

Компоненту StatusFilter потрібно значення фільтра з властивості statusFilter
стану Redux, тому функція-селектор виглядатиме як state => state.filters.status.

5. Функції-селектори всі функції-селектори оголошуються в окремому файлі,
   наприклад, в src/redux/selectors.js, після чого імпортуються до компонентів.

src/redux/selectors.js export const getTasks = state => state.tasks; export
const getStatusFilter = state => state.filters.status;

Екшени - це об'єкти, які передають дані з компонентів у стор, тим самим
сигналізуючи про те, яка подія сталася в інтерфейсі. Вони являються єдиним
джерелом інформації для стору. const action = { type: "Action type", payload:
"Payload value", }; const addTask = { type: 'tasks/addTask', payload: { id:
'Generated id', text: 'User entered text', completed: false, }, };

const deleteTask = { type: 'tasks/deleteTask', payload: 'Task id', }; const
setStatusFilter = { type: 'filters/setStatusFilter', payload: 'Filter value', };

Генератори екшенів Екшени це статичні об'єкти, значення властивості payload яких
неможливо задати динамічно. Генератори екшенів (Action Creators) - функції, які
можуть приймати аргументи, після чого створюють та повертають екшени з однаковим
значенням властивості type, але різними payload. Вони можуть мати побічні
ефекти, наприклад, заповнювати властивості за замовчуванням або генерувати
унікальний ідентифікатор об'єкта завдання.

6. створимо генератри екшенів

7. Відправлення екшенів Для того щоб сповістити сторінку про те, що в інтерфейсі
   відбулася якась подія, необхідно відправити екшен. Для цього у бібліотеці
   React Redux є хук useDispatch(), який повертає посилання на функцію
   надсилання екшенів dispatch з об'єкта створеного нами раніше стора Redux.

````js
// Імпортуємо хук
import { useDispatch } from "react-redux";
const MyComponent = () => {
  // Отримуємо посилання на функцію відправки екшенів
  const dispatch = useDispatch();
};```



````

Додамо код відправлення раніше спроектованих екшенів із компонентів нашої
програми.

Створення завдання При сабміті форми в компоненті TaskForm необхідно надіслати
екшен створення нового завдання, передавши йому значення, введене користувачем у
текстове поле.

Видалення завдання При натисканні на кнопку видалення в компоненті Task,
необхідно відправити екшен видалення завдання, передавши йому ідентифікатор
завдання. Цих даних буде достатньо для видалення задачі з масиву об'єктів.

Переключення статусу При натисканні на чекбокс в компоненті Task, необхідно
відправити екшен перемикання статусу завдання, передавши йому ідентифікатор
завдання. Цих даних буде достатньо для того, щоб знайти завдання в масиві
об'єктів і змінити значення властивості на протилежне.

Зміна фільтра При натисканні на кнопки в компоненті StatusFilter необхідно
відправити екшен зміни фільтра, передавши йому нове значення. Використовуємо
об'єкт значень фільтр з файлу констант.

На даний момент у додатку реалізовано ініціалізацію стора з інструментами
розробника, підписка компонентів на стор і надсилання екшенів. Наступним кроком
буде додавання логіки оновлення стану Redux за допомогою функцій-редюсерів.

8. Редюсери (reducers) Ми спроектували стан програми, пов'язали компоненти та
   стор, додали відправлення екшенів. Настав час написати логіку зміни стану
   Redux. Редюсер (reducer) - це функція, яка приймає поточний стан та екшен як
   аргументи і повертає новий стан. Редюсер визначає, як змінюється стан
   програми у відповідь на екшени, надіслані на стор. Пам'ятайте, що екшени
   описують тільки те, що сталося, а не як змінюється стан програми.

(state, action) => nextState

Кореневий редюсер У додатку завжди буде лише один кореневий редюсер, який
потрібно передати до createStore під час створення стора. Цей редюсер відповідає
за обробку всіх відправлених екшенів та обчислення нового стану.

```js
import { statusFilters } from './constants';
const initialState = {
  tasks: [
    { id: 0, text: 'Learn HTML and CSS', completed: true },
    { id: 1, text: 'Get good at JavaScript', completed: true },
    { id: 2, text: 'Master React', completed: false },
    { id: 3, text: 'Discover Redux', completed: false },
    { id: 4, text: 'Build amazing apps', completed: false },
  ],
  filters: {
    status: statusFilters.all,
  },
};
// Використовуємо initialState як значення стану за умовчанням
export const rootReducer = (state = initialState, action) => {
  // Редюсер розрізняє екшени за значенням властивості type
  switch (action.type) {
    // Залежно від типу екшену виконуватиметься різна логіка
    default:
      // Кожен редюсер отримує всі екшени, відправлені в стор.
      // Якщо редюсер не повинен обробляти якийсь тип екшену,
      // необхідно повернути наявний стан без змін.
      return state;
  }
};
```

При ініціалізації стора (екшен @@INIT у Redux DevTools) всім редюсерам у якості
значення стану передається undefined. Тому кожному редюсеру необхідно вказати
значення за замовчуванням для параметра state, яке стане початковим станом
програми. Код файлу створення стора імпортує та використовує кореневий редюсер.

```js
import { createStore } from 'redux';
import { devToolsEnhancer } from '@redux-devtools/extension';
import { rootReducer } from './reducer';

const enhancer = devToolsEnhancer();
export const store = createStore(rootReducer, enhancer);
```

Якщо тепер спробувати додати нове завдання до інтерфейсу нашої програми, то у
списку завдань з'явиться новий елемент. Справа в тому, що хук useSelector змушує
компонент рендери повторно кожного разу при зміні тієї частини стану, на яку
підписаний компонент.

9. Обробка екшенів Додамо в кореневий редюсер код обробки всіх інших екшенів
   нашої програми.

Видалення завдання При видаленні нам доступний ідентифікатор завдання у
властивості payload, тому використовуємо метод Array.filter() для того, щоб
іммутабельно створити новий масив без цього завдання. Перевіряємо, чи відповідає
тип відправленого екшену рядку "tasks/deleteTask" та повертаємо новий об'єкт
стану.

Переключення статусу При перемиканні статусу нам доступний ідентифікатор
завдання у властивості payload, тому використовуємо метод Array.map() для того,
щоб іммутабельно створити новий масив із зміненим значенням властивості
completed у задачі з відповідним ідентифікатором. Перевіряємо, чи відповідає тип
відправленого екшену рядку "tasks/toggleCompleted" та повертаємо новий об'єкт
стану.

Зміна фільтра При зміні фільтра нам доступне нове значення фільтра payload, тому
перевіряємо чи відповідає тип відправленого екшену рядку
"filters/setStatusFilter" та повертаємо новий об'єкт стану.

Композиція редюсерів код кореневого редюсера вже стає громіздким. Тому редюсери
зазвичай поділяються на кілька дрібніших, щоб спростити розуміння і підтримку
коду

10. Розділимо обробку екшенів завдань та зміни фільтра на два незалежних
    редюсера. Кожен редюсер відповідатиме лише за свою частину стану Redux
